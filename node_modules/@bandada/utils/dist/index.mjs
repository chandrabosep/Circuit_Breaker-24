/**
 * @module @bandada/utils
 * @version 1.1.0
 * @file General Bandada utility functions.
 * @copyright Ethereum Foundation 2023
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/bandada/tree/main/libs/utils}
*/
import { Contract } from '@ethersproject/contracts';
import { InfuraProvider, JsonRpcProvider } from '@ethersproject/providers';
import { Wallet } from '@ethersproject/wallet';
import { formatBytes32String } from '@ethersproject/strings';
import axios from 'axios';
import { getAddress } from '@ethersproject/address';

/* istanbul ignore file */
var CONTRACT_ADDRESSES = {
    localhost: {
        Semaphore: "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
        Bandada: "0x5fbdb2315678afecb367f032d93f642f64180aa3",
        BandadaSemaphore: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
    },
    goerli: {
        Semaphore: "0x3889927F0B5Eb1a02C6E2C20b39a1Bd4EAd76131",
        Bandada: "0xB6f17dB678Dab765bC684Fd6BaA0F222Af388F77",
        BandadaSemaphore: "0xa0Bf12642C66Fc17d706D3FA7C9eB8EfAEA67d02"
    }
};
function getContractAddresses(networkName) {
    return CONTRACT_ADDRESSES[networkName];
}

var abi$1 = [
	{
		inputs: [
			{
				internalType: "contract ISemaphoreVerifier",
				name: "_verifier",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
		],
		name: "Semaphore__CallerIsNotTheGroupAdmin",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__GroupAlreadyExists",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__GroupDoesNotExist",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeDepthIsNotSupported",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeRootIsExpired",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeRootIsNotPartOfTheGroup",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__YouAreUsingTheSameNillifierTwice",
		type: "error"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "oldAdmin",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "GroupAdminUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeDepth",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "zeroValue",
				type: "uint256"
			}
		],
		name: "GroupCreated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "oldMerkleTreeDuration",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newMerkleTreeDuration",
				type: "uint256"
			}
		],
		name: "GroupMerkleTreeDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newIdentityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "externalNullifier",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "nullifierHash",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "signal",
				type: "uint256"
			}
		],
		name: "ProofVerified",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			}
		],
		name: "addMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "identityCommitments",
				type: "uint256[]"
			}
		],
		name: "addMembers",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "merkleTreeDepth",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "admin",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "merkleTreeDuration",
				type: "uint256"
			}
		],
		name: "createGroup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "merkleTreeDepth",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "admin",
				type: "address"
			}
		],
		name: "createGroup",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getMerkleTreeDepth",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getMerkleTreeRoot",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getNumberOfMerkleTreeLeaves",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "groups",
		outputs: [
			{
				internalType: "address",
				name: "admin",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "merkleTreeDuration",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "proofSiblings",
				type: "uint256[]"
			},
			{
				internalType: "uint8[]",
				name: "proofPathIndices",
				type: "uint8[]"
			}
		],
		name: "removeMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "updateGroupAdmin",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "newMerkleTreeDuration",
				type: "uint256"
			}
		],
		name: "updateGroupMerkleTreeDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "newIdentityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "proofSiblings",
				type: "uint256[]"
			},
			{
				internalType: "uint8[]",
				name: "proofPathIndices",
				type: "uint8[]"
			}
		],
		name: "updateMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "verifier",
		outputs: [
			{
				internalType: "contract ISemaphoreVerifier",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "signal",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "nullifierHash",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "externalNullifier",
				type: "uint256"
			},
			{
				internalType: "uint256[8]",
				name: "proof",
				type: "uint256[8]"
			}
		],
		name: "verifyProof",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "id",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "fingerprint",
				type: "uint256"
			}
		],
		name: "GroupUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "fingerprintCreationDates",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "fingerprintDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "fingerprint",
				type: "uint256"
			}
		],
		name: "getFingerprintCreationDate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "groups",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "durationSeconds",
				type: "uint256"
			}
		],
		name: "updateFingerprintDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "uint256",
						name: "id",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "fingerprint",
						type: "uint256"
					}
				],
				internalType: "struct IBandada.Group[]",
				name: "_groups",
				type: "tuple[]"
			}
		],
		name: "updateGroups",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

/* istanbul ignore file */
function getProvider(network, apiKey) {
    switch (network) {
        case "localhost":
            return new JsonRpcProvider("http://127.0.0.1:8545");
        case "goerli":
            return new InfuraProvider(network, apiKey);
        default:
            throw new TypeError("'".concat(network, "' network is not supported"));
    }
}

/* istanbul ignore file */
function getWallet(privateKey, network, apiKey) {
    if (network) {
        var provider = getProvider(network, apiKey);
        return new Wallet(privateKey, provider);
    }
    return new Wallet(privateKey);
}

/* istanbul ignore file */
function getContract(contractName, network, privateKeyOrSigner, apiKey) {
    var providerOrWallet;
    if (privateKeyOrSigner) {
        if (typeof privateKeyOrSigner === "string") {
            providerOrWallet = getWallet(privateKeyOrSigner, network, apiKey);
        }
        else {
            providerOrWallet = privateKeyOrSigner;
        }
    }
    else {
        providerOrWallet = getProvider(network, apiKey);
    }
    var contractAddress = getContractAddresses(network)[contractName];
    switch (contractName) {
        case "Bandada":
            return new Contract(contractAddress, abi, providerOrWallet);
        case "Semaphore":
            return new Contract(contractAddress, abi$1, providerOrWallet);
        default:
            throw new TypeError("'".concat(contractName, "' contract does not exist"));
    }
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/* istanbul ignore file */
var SemaphoreContract = /** @class */ (function () {
    function SemaphoreContract(contract) {
        this.contract = contract;
    }
    SemaphoreContract.prototype.createGroup = function (groupName, merkleTreeDepth, admin) {
        return __awaiter(this, void 0, void 0, function () {
            var groupId, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        groupId = BigInt(formatBytes32String(groupName));
                        return [4 /*yield*/, this.contract["createGroup(uint256,uint256,address)"](groupId, merkleTreeDepth, admin)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    SemaphoreContract.prototype.updateGroupAdmin = function (groupName, newAdmin) {
        return __awaiter(this, void 0, void 0, function () {
            var groupId, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        groupId = BigInt(formatBytes32String(groupName));
                        return [4 /*yield*/, this.contract.updateGroupAdmin(groupId, newAdmin)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    SemaphoreContract.prototype.addMember = function (groupName, member) {
        return __awaiter(this, void 0, void 0, function () {
            var groupId, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        groupId = BigInt(formatBytes32String(groupName));
                        return [4 /*yield*/, this.contract.addMember(groupId, member)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    SemaphoreContract.prototype.addMembers = function (groupName, members) {
        return __awaiter(this, void 0, void 0, function () {
            var groupId, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        groupId = BigInt(formatBytes32String(groupName));
                        return [4 /*yield*/, this.contract.addMembers(groupId, members)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    return SemaphoreContract;
}());
function getSemaphoreContract(network, privateKeyOrSigner, apiKey) {
    var contract = getContract("Semaphore", network, privateKeyOrSigner, apiKey);
    return new SemaphoreContract(contract);
}

/* istanbul ignore file */
var BandadaContract = /** @class */ (function () {
    function BandadaContract(contract) {
        this.contract = contract;
    }
    BandadaContract.prototype.updateGroups = function (groups) {
        return __awaiter(this, void 0, void 0, function () {
            var transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contract.updateGroups(groups)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    BandadaContract.prototype.getGroups = function () {
        return __awaiter(this, void 0, void 0, function () {
            var filter, events;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        filter = this.contract.filters.GroupUpdated();
                        return [4 /*yield*/, this.contract.queryFilter(filter)];
                    case 1:
                        events = _a.sent();
                        return [2 /*return*/, events.map(function (_a) {
                                var args = _a.args;
                                return ({
                                    id: args[0].toBigInt(),
                                    fingerprint: args[1].toBigInt()
                                });
                            })];
                }
            });
        });
    };
    BandadaContract.prototype.updateFingerprintDuration = function (groupId, fingerprintDuration) {
        return __awaiter(this, void 0, void 0, function () {
            var transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contract.updateFingerprintDuration(groupId, fingerprintDuration)];
                    case 1:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction.wait(1)];
                }
            });
        });
    };
    return BandadaContract;
}());
function getBandadaContract(network, privateKeyOrSigner, apiKey) {
    var contract = getContract("Bandada", network, privateKeyOrSigner, apiKey);
    return new BandadaContract(contract);
}

/* istanbul ignore file */
function request(url, config) {
    return __awaiter(this, void 0, void 0, function () {
        var data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, axios(url, __assign({ withCredentials: true }, config))];
                case 1:
                    data = (_a.sent()).data;
                    return [2 /*return*/, data];
            }
        });
    });
}

function shortenAddress(address, chars) {
    if (chars === void 0) { chars = 4; }
    address = getAddress(address);
    return "".concat(address.substring(0, chars + 2), "...").concat(address.substring(42 - chars));
}

export { abi as BandadaABI, BandadaContract, CONTRACT_ADDRESSES, abi$1 as SemaphoreABI, SemaphoreContract, getBandadaContract, getContract, getContractAddresses, getProvider, getSemaphoreContract, getWallet, request, shortenAddress };
